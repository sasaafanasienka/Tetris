{"ast":null,"code":"import React, { useState, useEffect } from 'react'; // import addNewBlock from '../gameEvents/addNewBlock';\n\nimport DataTransform from './DataTransform';\nlet dataTransform = new DataTransform();\nexport default class MoveDown extends React.Component {\n  stopBlock(currentArea) {\n    let newArea = [];\n\n    for (let row = 0; row < 24; row++) {\n      if (!currentArea[row].includes(1)) {\n        newArea.push(currentArea[row]);\n      }\n    }\n  }\n\n  removeFullRows(area) {\n    let filteredArea = area.filter(row => {\n      return row.some(el => {\n        return el === 0;\n      });\n    });\n    return area;\n  }\n\n  move(currentArea) {\n    let newArea = [];\n\n    for (let row = 23; row >= 0; row--) {\n      if (!currentArea[row].includes(1)) {\n        //если строка не сожержит дижущихся элементов\n        newArea.unshift(currentArea[row]); //то она добавляется без изменений\n      } else {\n        for (let column = 0; column < 9; column++) {\n          if (currentArea[row][column] === 1 && newArea[0][column] !== 2) {\n            currentArea[row][column] = 0;\n            newArea[0][column] = 1;\n          } else {\n            return this.stopBlock(currentArea);\n          }\n        }\n\n        newArea.unshift(currentArea[row]);\n      }\n    }\n\n    return newArea;\n  }\n\n}","map":{"version":3,"sources":["D:/FrontEnd/03-tetris/src/blockMoves/MoveDown.js"],"names":["React","useState","useEffect","DataTransform","dataTransform","MoveDown","Component","stopBlock","currentArea","newArea","row","includes","push","removeFullRows","area","filteredArea","filter","some","el","move","unshift","column"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C,C,CACA;;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,IAAIC,aAAa,GAAG,IAAID,aAAJ,EAApB;AAEA,eAAe,MAAME,QAAN,SAAuBL,KAAK,CAACM,SAA7B,CAAuC;AAElDC,EAAAA,SAAS,CAACC,WAAD,EAAc;AACnB,QAAIC,OAAO,GAAG,EAAd;;AACA,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,EAAxB,EAA4BA,GAAG,EAA/B,EAAmC;AAC/B,UAAI,CAACF,WAAW,CAACE,GAAD,CAAX,CAAiBC,QAAjB,CAA0B,CAA1B,CAAL,EAAmC;AAC/BF,QAAAA,OAAO,CAACG,IAAR,CAAaJ,WAAW,CAACE,GAAD,CAAxB;AACH;AACJ;AACJ;;AAEDG,EAAAA,cAAc,CAACC,IAAD,EAAO;AACjB,QAAIC,YAAY,GAAGD,IAAI,CAACE,MAAL,CAAaN,GAAD,IAAS;AACpC,aAAOA,GAAG,CAACO,IAAJ,CAAUC,EAAD,IAAQ;AACpB,eAAOA,EAAE,KAAK,CAAd;AACH,OAFM,CAAP;AAGH,KAJkB,CAAnB;AAKA,WAAOJ,IAAP;AACH;;AAEDK,EAAAA,IAAI,CAACX,WAAD,EAAc;AACd,QAAIC,OAAO,GAAG,EAAd;;AACA,SAAK,IAAIC,GAAG,GAAG,EAAf,EAAmBA,GAAG,IAAI,CAA1B,EAA6BA,GAAG,EAAhC,EAAoC;AAChC,UAAI,CAACF,WAAW,CAACE,GAAD,CAAX,CAAiBC,QAAjB,CAA0B,CAA1B,CAAL,EAAmC;AAAE;AACjCF,QAAAA,OAAO,CAACW,OAAR,CAAgBZ,WAAW,CAACE,GAAD,CAA3B,EAD+B,CACG;AACrC,OAFD,MAEO;AACH,aAAK,IAAIW,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAG,CAA9B,EAAiCA,MAAM,EAAvC,EAA2C;AACvC,cAAIb,WAAW,CAACE,GAAD,CAAX,CAAiBW,MAAjB,MAA6B,CAA7B,IAAkCZ,OAAO,CAAC,CAAD,CAAP,CAAWY,MAAX,MAAuB,CAA7D,EAAgE;AAC5Db,YAAAA,WAAW,CAACE,GAAD,CAAX,CAAiBW,MAAjB,IAA2B,CAA3B;AACAZ,YAAAA,OAAO,CAAC,CAAD,CAAP,CAAWY,MAAX,IAAqB,CAArB;AACH,WAHD,MAGO;AACH,mBAAO,KAAKd,SAAL,CAAeC,WAAf,CAAP;AACH;AACJ;;AACDC,QAAAA,OAAO,CAACW,OAAR,CAAgBZ,WAAW,CAACE,GAAD,CAA3B;AACH;AACJ;;AACD,WAAOD,OAAP;AACH;;AAtCiD","sourcesContent":["import React, { useState, useEffect } from 'react';\r\n// import addNewBlock from '../gameEvents/addNewBlock';\r\nimport DataTransform from './DataTransform'\r\nlet dataTransform = new DataTransform()\r\n\r\nexport default class MoveDown extends React.Component {\r\n\r\n    stopBlock(currentArea) {\r\n        let newArea = []\r\n        for (let row = 0; row < 24; row++) {\r\n            if (!currentArea[row].includes(1)) {\r\n                newArea.push(currentArea[row])\r\n            }\r\n        }\r\n    }\r\n\r\n    removeFullRows(area) {\r\n        let filteredArea = area.filter((row) => {\r\n            return row.some((el) => {\r\n                return el === 0\r\n            })\r\n        })\r\n        return area\r\n    }\r\n\r\n    move(currentArea) {\r\n        let newArea = []\r\n        for (let row = 23; row >= 0; row--) {\r\n            if (!currentArea[row].includes(1)) { //если строка не сожержит дижущихся элементов\r\n                newArea.unshift(currentArea[row]) //то она добавляется без изменений\r\n            } else {\r\n                for (let column = 0; column < 9; column++) {\r\n                    if (currentArea[row][column] === 1 && newArea[0][column] !== 2) {\r\n                        currentArea[row][column] = 0\r\n                        newArea[0][column] = 1\r\n                    } else {\r\n                        return this.stopBlock(currentArea)\r\n                    }\r\n                }\r\n                newArea.unshift(currentArea[row])\r\n            }\r\n        }\r\n        return newArea\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}